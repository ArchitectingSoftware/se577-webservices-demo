import { L } from "ts-toolbelt";
import { DoesExtend, Not } from "../utils";
import { Never, NeverType } from "./never";
import { Type } from "./type";
import { Resolve } from "./resolve";
export declare type TupleTypeId = "tuple";
export declare type Tuple<V extends Type[], P extends Type = Never> = $Tuple<V, P>;
export declare type $Tuple<V, P = Never> = IsAnyValueNever<V> extends true ? Never : {
    type: TupleTypeId;
    values: V;
    isOpen: Not<DoesExtend<P, NeverType>>;
    openProps: P;
};
declare type IsAnyValueNever<V> = {
    stop: false;
    continue: V extends any[] ? L.Head<V> extends NeverType ? true : IsAnyValueNever<L.Tail<V>> : true;
}[V extends [any, ...any[]] ? "continue" : "stop"];
export declare type TupleType = {
    type: TupleTypeId;
    values: Type[];
    isOpen: boolean;
    openProps: Type;
};
export declare type TupleValues<T extends TupleType> = T["values"];
export declare type IsTupleOpen<T extends TupleType> = T["isOpen"];
export declare type TupleOpenProps<T extends TupleType> = T["openProps"];
export declare type ResolveTuple<T extends TupleType> = IsTupleOpen<T> extends true ? L.Concat<RecurseOnTuple<TupleValues<T>>, [...Resolve<TupleOpenProps<T>>[]]> : RecurseOnTuple<TupleValues<T>>;
declare type RecurseOnTuple<V extends Type[], R extends any[] = []> = {
    stop: L.Reverse<R>;
    continue: RecurseOnTuple<L.Tail<V>, L.Prepend<R, Resolve<L.Head<V>>>>;
}[V extends [any, ...any[]] ? "continue" : "stop"];
export {};
